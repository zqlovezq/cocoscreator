{"version":3,"sources":["file:///C:/chickenStarClient/client/node_modules/protobufjs/src/tokenize.js"],"names":["_cjsLoader","__cjsMetaURL","url","define","exports","require","module","__filename","__dirname","tokenize","delimRe","stringDoubleRe","stringSingleRe","setCommentRe","setCommentAltRe","setCommentSplitRe","whitespaceRe","unescapeRe","unescapeMap","unescape","str","replace","$0","$1","source","alternateCommentMode","toString","offset","length","line","lastCommentLine","comments","stack","stringDelim","illegal","subject","Error","readString","re","lastIndex","match","exec","push","charAt","pos","setComment","start","end","isLeading","comment","type","lineEmpty","leading","lookback","commentOffset","c","lines","substring","split","i","trim","text","join","isDoubleSlashCommentLine","startOffset","endOffset","findEndOfLine","lineText","isComment","test","cursor","next","shift","repeat","prev","curr","isDoc","isLeadingComment","Math","min","delim","token","peek","skip","expected","optional","actual","equals","cmnt","trailingLine","ret","undefined","Object","defineProperty","get","_cjsExports"],"mappings":"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","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nlet _cjsExports;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n \"use strict\";\n module.exports = tokenize;\n\n var delimRe        = /[\\s{}=;:[\\],'\"()<>]/g,\n     stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n     stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\n\n var setCommentRe = /^ *[*/]+ */,\n     setCommentAltRe = /^\\s*\\*?\\/*/,\n     setCommentSplitRe = /\\n/g,\n     whitespaceRe = /\\s/,\n     unescapeRe = /\\\\(.?)/g;\n\n var unescapeMap = {\n     \"0\": \"\\0\",\n     \"r\": \"\\r\",\n     \"n\": \"\\n\",\n     \"t\": \"\\t\"\n };\n\n /**\n  * Unescapes a string.\n  * @param {string} str String to unescape\n  * @returns {string} Unescaped string\n  * @property {Object.<string,string>} map Special characters map\n  * @memberof tokenize\n  */\n function unescape(str) {\n     return str.replace(unescapeRe, function($0, $1) {\n         switch ($1) {\n             case \"\\\\\":\n             case \"\":\n                 return $1;\n             default:\n                 return unescapeMap[$1] || \"\";\n         }\n     });\n }\n\n tokenize.unescape = unescape;\n\n /**\n  * Gets the next token and advances.\n  * @typedef TokenizerHandleNext\n  * @type {function}\n  * @returns {string|null} Next token or `null` on eof\n  */\n\n /**\n  * Peeks for the next token.\n  * @typedef TokenizerHandlePeek\n  * @type {function}\n  * @returns {string|null} Next token or `null` on eof\n  */\n\n /**\n  * Pushes a token back to the stack.\n  * @typedef TokenizerHandlePush\n  * @type {function}\n  * @param {string} token Token\n  * @returns {undefined}\n  */\n\n /**\n  * Skips the next token.\n  * @typedef TokenizerHandleSkip\n  * @type {function}\n  * @param {string} expected Expected token\n  * @param {boolean} [optional=false] If optional\n  * @returns {boolean} Whether the token matched\n  * @throws {Error} If the token didn't match and is not optional\n  */\n\n /**\n  * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n  * @typedef TokenizerHandleCmnt\n  * @type {function}\n  * @param {number} [line] Line number\n  * @returns {string|null} Comment text or `null` if none\n  */\n\n /**\n  * Handle object returned from {@link tokenize}.\n  * @interface ITokenizerHandle\n  * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n  * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n  * @property {TokenizerHandlePush} push Pushes a token back to the stack\n  * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n  * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n  * @property {number} line Current line number\n  */\n\n /**\n  * Tokenizes the given .proto source and returns an object with useful utility functions.\n  * @param {string} source Source contents\n  * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n  * @returns {ITokenizerHandle} Tokenizer handle\n  */\n function tokenize(source, alternateCommentMode) {\n     /* eslint-disable callback-return */\n     source = source.toString();\n\n     var offset = 0,\n         length = source.length,\n         line = 1,\n         lastCommentLine = 0,\n         comments = {};\n\n     var stack = [];\n\n     var stringDelim = null;\n\n     /* istanbul ignore next */\n     /**\n      * Creates an error for illegal syntax.\n      * @param {string} subject Subject\n      * @returns {Error} Error created\n      * @inner\n      */\n     function illegal(subject) {\n         return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n     }\n\n     /**\n      * Reads a string till its end.\n      * @returns {string} String read\n      * @inner\n      */\n     function readString() {\n         var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n         re.lastIndex = offset - 1;\n         var match = re.exec(source);\n         if (!match)\n             throw illegal(\"string\");\n         offset = re.lastIndex;\n         push(stringDelim);\n         stringDelim = null;\n         return unescape(match[1]);\n     }\n\n     /**\n      * Gets the character at `pos` within the source.\n      * @param {number} pos Position\n      * @returns {string} Character\n      * @inner\n      */\n     function charAt(pos) {\n         return source.charAt(pos);\n     }\n\n     /**\n      * Sets the current comment text.\n      * @param {number} start Start offset\n      * @param {number} end End offset\n      * @param {boolean} isLeading set if a leading comment\n      * @returns {undefined}\n      * @inner\n      */\n     function setComment(start, end, isLeading) {\n         var comment = {\n             type: source.charAt(start++),\n             lineEmpty: false,\n             leading: isLeading,\n         };\n         var lookback;\n         if (alternateCommentMode) {\n             lookback = 2;  // alternate comment parsing: \"//\" or \"/*\"\n         } else {\n             lookback = 3;  // \"///\" or \"/**\"\n         }\n         var commentOffset = start - lookback,\n             c;\n         do {\n             if (--commentOffset < 0 ||\n                     (c = source.charAt(commentOffset)) === \"\\n\") {\n                 comment.lineEmpty = true;\n                 break;\n             }\n         } while (c === \" \" || c === \"\\t\");\n         var lines = source\n             .substring(start, end)\n             .split(setCommentSplitRe);\n         for (var i = 0; i < lines.length; ++i)\n             lines[i] = lines[i]\n                 .replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\")\n                 .trim();\n         comment.text = lines\n             .join(\"\\n\")\n             .trim();\n\n         comments[line] = comment;\n         lastCommentLine = line;\n     }\n\n     function isDoubleSlashCommentLine(startOffset) {\n         var endOffset = findEndOfLine(startOffset);\n\n         // see if remaining line matches comment pattern\n         var lineText = source.substring(startOffset, endOffset);\n         var isComment = /^\\s*\\/\\//.test(lineText);\n         return isComment;\n     }\n\n     function findEndOfLine(cursor) {\n         // find end of cursor's line\n         var endOffset = cursor;\n         while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n             endOffset++;\n         }\n         return endOffset;\n     }\n\n     /**\n      * Obtains the next token.\n      * @returns {string|null} Next token or `null` on eof\n      * @inner\n      */\n     function next() {\n         if (stack.length > 0)\n             return stack.shift();\n         if (stringDelim)\n             return readString();\n         var repeat,\n             prev,\n             curr,\n             start,\n             isDoc,\n             isLeadingComment = offset === 0;\n         do {\n             if (offset === length)\n                 return null;\n             repeat = false;\n             while (whitespaceRe.test(curr = charAt(offset))) {\n                 if (curr === \"\\n\") {\n                     isLeadingComment = true;\n                     ++line;\n                 }\n                 if (++offset === length)\n                     return null;\n             }\n\n             if (charAt(offset) === \"/\") {\n                 if (++offset === length) {\n                     throw illegal(\"comment\");\n                 }\n                 if (charAt(offset) === \"/\") { // Line\n                     if (!alternateCommentMode) {\n                         // check for triple-slash comment\n                         isDoc = charAt(start = offset + 1) === \"/\";\n\n                         while (charAt(++offset) !== \"\\n\") {\n                             if (offset === length) {\n                                 return null;\n                             }\n                         }\n                         ++offset;\n                         if (isDoc) {\n                             setComment(start, offset - 1, isLeadingComment);\n                             // Trailing comment cannot not be multi-line,\n                             // so leading comment state should be reset to handle potential next comments\n                             isLeadingComment = true;\n                         }\n                         ++line;\n                         repeat = true;\n                     } else {\n                         // check for double-slash comments, consolidating consecutive lines\n                         start = offset;\n                         isDoc = false;\n                         if (isDoubleSlashCommentLine(offset - 1)) {\n                             isDoc = true;\n                             do {\n                                 offset = findEndOfLine(offset);\n                                 if (offset === length) {\n                                     break;\n                                 }\n                                 offset++;\n                                 if (!isLeadingComment) {\n                                     // Trailing comment cannot not be multi-line\n                                     break;\n                                 }\n                             } while (isDoubleSlashCommentLine(offset));\n                         } else {\n                             offset = Math.min(length, findEndOfLine(offset) + 1);\n                         }\n                         if (isDoc) {\n                             setComment(start, offset, isLeadingComment);\n                             isLeadingComment = true;\n                         }\n                         line++;\n                         repeat = true;\n                     }\n                 } else if ((curr = charAt(offset)) === \"*\") { /* Block */\n                     // check for /** (regular comment mode) or /* (alternate comment mode)\n                     start = offset + 1;\n                     isDoc = alternateCommentMode || charAt(start) === \"*\";\n                     do {\n                         if (curr === \"\\n\") {\n                             ++line;\n                         }\n                         if (++offset === length) {\n                             throw illegal(\"comment\");\n                         }\n                         prev = curr;\n                         curr = charAt(offset);\n                     } while (prev !== \"*\" || curr !== \"/\");\n                     ++offset;\n                     if (isDoc) {\n                         setComment(start, offset - 2, isLeadingComment);\n                         isLeadingComment = true;\n                     }\n                     repeat = true;\n                 } else {\n                     return \"/\";\n                 }\n             }\n         } while (repeat);\n\n         // offset !== length if we got here\n\n         var end = offset;\n         delimRe.lastIndex = 0;\n         var delim = delimRe.test(charAt(end++));\n         if (!delim)\n             while (end < length && !delimRe.test(charAt(end)))\n                 ++end;\n         var token = source.substring(offset, offset = end);\n         if (token === \"\\\"\" || token === \"'\")\n             stringDelim = token;\n         return token;\n     }\n\n     /**\n      * Pushes a token back to the stack.\n      * @param {string} token Token\n      * @returns {undefined}\n      * @inner\n      */\n     function push(token) {\n         stack.push(token);\n     }\n\n     /**\n      * Peeks for the next token.\n      * @returns {string|null} Token or `null` on eof\n      * @inner\n      */\n     function peek() {\n         if (!stack.length) {\n             var token = next();\n             if (token === null)\n                 return null;\n             push(token);\n         }\n         return stack[0];\n     }\n\n     /**\n      * Skips a token.\n      * @param {string} expected Expected token\n      * @param {boolean} [optional=false] Whether the token is optional\n      * @returns {boolean} `true` when skipped, `false` if not\n      * @throws {Error} When a required token is not present\n      * @inner\n      */\n     function skip(expected, optional) {\n         var actual = peek(),\n             equals = actual === expected;\n         if (equals) {\n             next();\n             return true;\n         }\n         if (!optional)\n             throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n         return false;\n     }\n\n     /**\n      * Gets a comment.\n      * @param {number} [trailingLine] Line number if looking for a trailing comment\n      * @returns {string|null} Comment text\n      * @inner\n      */\n     function cmnt(trailingLine) {\n         var ret = null;\n         var comment;\n         if (trailingLine === undefined) {\n             comment = comments[line - 1];\n             delete comments[line - 1];\n             if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                 ret = comment.leading ? comment.text : null;\n             }\n         } else {\n             /* istanbul ignore else */\n             if (lastCommentLine < trailingLine) {\n                 peek();\n             }\n             comment = comments[trailingLine];\n             delete comments[trailingLine];\n             if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                 ret = comment.leading ? null : comment.text;\n             }\n         }\n         return ret;\n     }\n\n     return Object.defineProperty({\n         next: next,\n         peek: peek,\n         push: push,\n         skip: skip,\n         cmnt: cmnt\n     }, \"line\", {\n         get: function() { return line; }\n     });\n     /* eslint-enable callback-return */\n }\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n\n\n}, {});\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}