{"version":3,"sources":["file:///C:/chickenStarClient/client/node_modules/@protobufjs/codegen/index.js"],"names":["_cjsLoader","__cjsMetaURL","url","define","exports","require","module","__filename","__dirname","codegen","functionParams","functionName","undefined","body","Codegen","formatStringOrScope","source","toString","verbose","console","log","scopeKeys","Object","keys","scopeParams","Array","length","scopeValues","scopeOffset","Function","apply","formatParams","arguments","formatOffset","replace","$0","$1","value","String","Number","Math","floor","JSON","stringify","Error","push","functionNameOverride","join","_cjsExports"],"mappings":"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","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nlet _cjsExports;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n \"use strict\";\r\n module.exports = codegen;\r\n\r\n /**\r\n  * Begins generating a function.\r\n  * @memberof util\r\n  * @param {string[]} functionParams Function parameter names\r\n  * @param {string} [functionName] Function name if not anonymous\r\n  * @returns {Codegen} Appender that appends code to the function's body\r\n  */\r\n function codegen(functionParams, functionName) {\r\n\r\n     /* istanbul ignore if */\r\n     if (typeof functionParams === \"string\") {\r\n         functionName = functionParams;\r\n         functionParams = undefined;\r\n     }\r\n\r\n     var body = [];\r\n\r\n     /**\r\n      * Appends code to the function's body or finishes generation.\r\n      * @typedef Codegen\r\n      * @type {function}\r\n      * @param {string|Object.<string,*>} [formatStringOrScope] Format string or, to finish the function, an object of additional scope variables, if any\r\n      * @param {...*} [formatParams] Format parameters\r\n      * @returns {Codegen|Function} Itself or the generated function if finished\r\n      * @throws {Error} If format parameter counts do not match\r\n      */\r\n\r\n     function Codegen(formatStringOrScope) {\r\n         // note that explicit array handling below makes this ~50% faster\r\n\r\n         // finish the function\r\n         if (typeof formatStringOrScope !== \"string\") {\r\n             var source = toString();\r\n             if (codegen.verbose)\r\n                 console.log(\"codegen: \" + source); // eslint-disable-line no-console\r\n             source = \"return \" + source;\r\n             if (formatStringOrScope) {\r\n                 var scopeKeys   = Object.keys(formatStringOrScope),\r\n                     scopeParams = new Array(scopeKeys.length + 1),\r\n                     scopeValues = new Array(scopeKeys.length),\r\n                     scopeOffset = 0;\r\n                 while (scopeOffset < scopeKeys.length) {\r\n                     scopeParams[scopeOffset] = scopeKeys[scopeOffset];\r\n                     scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];\r\n                 }\r\n                 scopeParams[scopeOffset] = source;\r\n                 return Function.apply(null, scopeParams).apply(null, scopeValues); // eslint-disable-line no-new-func\r\n             }\r\n             return Function(source)(); // eslint-disable-line no-new-func\r\n         }\r\n\r\n         // otherwise append to body\r\n         var formatParams = new Array(arguments.length - 1),\r\n             formatOffset = 0;\r\n         while (formatOffset < formatParams.length)\r\n             formatParams[formatOffset] = arguments[++formatOffset];\r\n         formatOffset = 0;\r\n         formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {\r\n             var value = formatParams[formatOffset++];\r\n             switch ($1) {\r\n                 case \"d\": case \"f\": return String(Number(value));\r\n                 case \"i\": return String(Math.floor(value));\r\n                 case \"j\": return JSON.stringify(value);\r\n                 case \"s\": return String(value);\r\n             }\r\n             return \"%\";\r\n         });\r\n         if (formatOffset !== formatParams.length)\r\n             throw Error(\"parameter count mismatch\");\r\n         body.push(formatStringOrScope);\r\n         return Codegen;\r\n     }\r\n\r\n     function toString(functionNameOverride) {\r\n         return \"function \" + (functionNameOverride || functionName || \"\") + \"(\" + (functionParams && functionParams.join(\",\") || \"\") + \"){\\n  \" + body.join(\"\\n  \") + \"\\n}\";\r\n     }\r\n\r\n     Codegen.toString = toString;\r\n     return Codegen;\r\n }\r\n\r\n /**\r\n  * Begins generating a function.\r\n  * @memberof util\r\n  * @function codegen\r\n  * @param {string} [functionName] Function name if not anonymous\r\n  * @returns {Codegen} Appender that appends code to the function's body\r\n  * @variation 2\r\n  */\r\n\r\n /**\r\n  * When set to `true`, codegen will log generated code to console. Useful for debugging.\r\n  * @name util.codegen.verbose\r\n  * @type {boolean}\r\n  */\r\n codegen.verbose = false;\r\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n\n\n}, {});\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}