{"version":3,"sources":["file:///C:/chickenStarClient/client/node_modules/protobufjs/src/mapfield.js"],"names":["_cjsLoader","_req","__cjsMetaURL","_req0","_req1","url","define","exports","require","module","__filename","__dirname","MapField","Field","prototype","Object","create","constructor","className","types","util","name","id","keyType","type","options","comment","call","undefined","isString","TypeError","resolvedKeyType","map","fromJSON","json","toJSON","toJSONOptions","keepComments","Boolean","toObject","extend","resolve","resolved","mapKey","Error","d","decorateMapField","fieldId","fieldKeyType","fieldValueType","decorateType","decorateEnum","mapFieldDecorator","fieldName","add","_cjsExports"],"mappings":"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","sourcesContent":["import _cjsLoader from 'cce:/internal/ml/cjs-loader.mjs';\nimport { __cjsMetaURL as _req} from './field';\nimport { __cjsMetaURL as _req0} from './types';\nimport { __cjsMetaURL as _req1} from './util';\nlet _cjsExports;\nconst __cjsMetaURL = import.meta.url;\n_cjsLoader.define(__cjsMetaURL, function (exports, require, module, __filename, __dirname) {\n// #region ORIGINAL CODE\n\n\n \"use strict\";\n module.exports = MapField;\n\n // extends Field\n var Field = require(\"./field\");\n ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\n var types   = require(\"./types\"),\n     util    = require(\"./util\");\n\n /**\n  * Constructs a new map field instance.\n  * @classdesc Reflected map field.\n  * @extends FieldBase\n  * @constructor\n  * @param {string} name Unique name within its namespace\n  * @param {number} id Unique id within its namespace\n  * @param {string} keyType Key type\n  * @param {string} type Value type\n  * @param {Object.<string,*>} [options] Declared options\n  * @param {string} [comment] Comment associated with this field\n  */\n function MapField(name, id, keyType, type, options, comment) {\n     Field.call(this, name, id, type, undefined, undefined, options, comment);\n\n     /* istanbul ignore if */\n     if (!util.isString(keyType))\n         throw TypeError(\"keyType must be a string\");\n\n     /**\n      * Key type.\n      * @type {string}\n      */\n     this.keyType = keyType; // toJSON, marker\n\n     /**\n      * Resolved key type if not a basic type.\n      * @type {ReflectionObject|null}\n      */\n     this.resolvedKeyType = null;\n\n     // Overrides Field#map\n     this.map = true;\n }\n\n /**\n  * Map field descriptor.\n  * @interface IMapField\n  * @extends {IField}\n  * @property {string} keyType Key type\n  */\n\n /**\n  * Extension map field descriptor.\n  * @interface IExtensionMapField\n  * @extends IMapField\n  * @property {string} extend Extended type\n  */\n\n /**\n  * Constructs a map field from a map field descriptor.\n  * @param {string} name Field name\n  * @param {IMapField} json Map field descriptor\n  * @returns {MapField} Created map field\n  * @throws {TypeError} If arguments are invalid\n  */\n MapField.fromJSON = function fromJSON(name, json) {\n     return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n };\n\n /**\n  * Converts this map field to a map field descriptor.\n  * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n  * @returns {IMapField} Map field descriptor\n  */\n MapField.prototype.toJSON = function toJSON(toJSONOptions) {\n     var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n     return util.toObject([\n         \"keyType\" , this.keyType,\n         \"type\"    , this.type,\n         \"id\"      , this.id,\n         \"extend\"  , this.extend,\n         \"options\" , this.options,\n         \"comment\" , keepComments ? this.comment : undefined\n     ]);\n };\n\n /**\n  * @override\n  */\n MapField.prototype.resolve = function resolve() {\n     if (this.resolved)\n         return this;\n\n     // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n     if (types.mapKey[this.keyType] === undefined)\n         throw Error(\"invalid key type: \" + this.keyType);\n\n     return Field.prototype.resolve.call(this);\n };\n\n /**\n  * Map field decorator (TypeScript).\n  * @name MapField.d\n  * @function\n  * @param {number} fieldId Field id\n  * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n  * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n  * @returns {FieldDecorator} Decorator function\n  * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n  */\n MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n\n     // submessage value: decorate the submessage and use its name as the type\n     if (typeof fieldValueType === \"function\")\n         fieldValueType = util.decorateType(fieldValueType).name;\n\n     // enum reference value: create a reflected copy of the enum and keep reuseing it\n     else if (fieldValueType && typeof fieldValueType === \"object\")\n         fieldValueType = util.decorateEnum(fieldValueType).name;\n\n     return function mapFieldDecorator(prototype, fieldName) {\n         util.decorateType(prototype.constructor)\n             .add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n     };\n };\n\n\n// #endregion ORIGINAL CODE\n\n_cjsExports = module.exports;\n\n\n}, () => ({\n  './field': _req,\n  './types': _req0,\n  './util': _req1,\n}));\nexport { _cjsExports as default };\nexport { __cjsMetaURL }\n"]}