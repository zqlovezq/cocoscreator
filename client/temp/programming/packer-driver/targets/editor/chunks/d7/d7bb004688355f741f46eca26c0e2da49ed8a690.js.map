{"version":3,"sources":["file:///C:/chickenStarClient/client/assets/scripts/sensitive_word/src/index.ts"],"names":["Mint","Node","constructor","keys","ops","root","customCharacter","len","length","idx","add","build","queue","push","beginNode","map","children","key","node","failNode","fail","search","text","options","replace","fText","oText","words","verify","textLen","i","oKey","toLowerCase","word","depth","v","join","filter","delete","type","pop","carry","count","isDel","k","val","next","lowKey","put","lastIdx","nextNode","newNode"],"mappings":";;;oCA2BaA,I;;;;;;;;;;;;;;AAjBNC,MAAAA,I;;;;;;AAVP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;sBAmBaD,I,GAAN,MAAMA,IAAN,CAAW;AAIhBE,QAAAA,WAAW,CAACC,IAAD,EAAiBC,GAAjB,EAAoC;AAAA,eAH/CC,IAG+C,GAHlC;AAAA;AAAA,4BAAS,MAAT,CAGkC;AAAA,eAF/CC,eAE+C;AAC7C,gBAAMC,GAAG,GAAGJ,IAAI,CAACK,MAAjB;AACA,eAAKF,eAAL,GAAuB,CAAAF,GAAG,QAAH,YAAAA,GAAG,CAAEE,eAAL,KAAwB,GAA/C;;AAEA,eAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,GAAxB,EAA6BE,GAAG,EAAhC,EAAoC;AAClC,iBAAKC,GAAL,CAASP,IAAI,CAACM,GAAD,CAAb,EAAoB,KAApB;AACD;;AACD,eAAKE,KAAL;AACD,SAZe,CAchB;;;AACQA,QAAAA,KAAK,GAAG;AACd,gBAAMC,KAAa,GAAG,EAAtB;AACAA,UAAAA,KAAK,CAACC,IAAN,CAAW,KAAKR,IAAhB;AAEA,cAAII,GAAG,GAAG,CAAV;;AACA,iBAAOG,KAAK,CAACJ,MAAN,GAAeC,GAAtB,EAA2B;AACzB,kBAAMK,SAAS,GAAGF,KAAK,CAACH,GAAD,CAAvB;AACA,kBAAMM,GAAG,GAAGD,SAAS,CAACE,QAAtB;;AACA,iBAAK,MAAMC,GAAX,IAAkBH,SAAS,CAACE,QAA5B,EAAsC;AAAA;;AACpC,oBAAME,IAAI,GAAGH,GAAG,CAACE,GAAD,CAAhB;AACA,kBAAIE,QAAQ,GAAGL,SAAS,CAACM,IAAzB;;AAEA,qBAAOD,QAAQ,IAAI,CAACA,QAAQ,CAACH,QAAT,CAAkBC,GAAlB,CAApB,EAA4C;AAC1CE,gBAAAA,QAAQ,GAAGA,QAAQ,CAACC,IAApB;AACD;;AAEDF,cAAAA,IAAI,CAACE,IAAL,GAAY,cAAAD,QAAQ,SAAR,sBAAUH,QAAV,CAAmBC,GAAnB,MAA2B,KAAKZ,IAA5C;AAEAO,cAAAA,KAAK,CAACC,IAAN,CAAWK,IAAX;AACD;;AAEDT,YAAAA,GAAG;AACJ;AACF;;AAEOY,QAAAA,MAAM,CACZC,IADY,EAEZC,OAAsB,GAAG;AACvBC,UAAAA,OAAO,EAAE;AADc,SAFb,EAKZ;AACA,cAAIN,IAAsB,GAAG,KAAKb,IAAlC;AACA,gBAAMoB,KAAe,GAAG,EAAxB;AACA,gBAAMC,KAAe,GAAG,EAAxB;AACA,gBAAMC,KAAe,GAAG,EAAxB;AAEA,gBAAM;AAAEH,YAAAA,OAAO,GAAG,IAAZ;AAAkBI,YAAAA,MAAM,GAAG;AAA3B,cAAqCL,OAA3C;AAEA,gBAAMM,OAAO,GAAGP,IAAI,CAACd,MAArB;;AACA,eAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,OAApB,EAA6BC,CAAC,EAA9B,EAAkC;AAAA;;AAChC;AACA,kBAAMC,IAAI,GAAGT,IAAI,CAACQ,CAAD,CAAjB;AACA,kBAAMb,GAAG,GAAGc,IAAI,CAACC,WAAL,EAAZ;;AAEA,mBAAOd,IAAI,IAAI,WAACA,IAAD,aAAC,MAAMF,QAAN,CAAeC,GAAf,CAAD,CAAf,EAAqC;AAAA;;AACnCC,cAAAA,IAAI,aAAGA,IAAH,qBAAG,OAAME,IAAb;AACD;;AACDF,YAAAA,IAAI,GAAG,WAAAA,IAAI,SAAJ,mBAAMF,QAAN,CAAeC,GAAf,MAAuB,KAAKZ,IAAnC;AAEAoB,YAAAA,KAAK,CAACZ,IAAN,CAAWkB,IAAX;AACAL,YAAAA,KAAK,CAACb,IAAN,CAAWkB,IAAX;;AAEA,gBAAIb,IAAI,CAACe,IAAT,EAAe;AACb,kBAAIxB,GAAG,GAAGqB,CAAC,GAAG,CAAJ,GAAQZ,IAAI,CAACgB,KAAvB;AACA,kBAAID,IAAI,GAAG,EAAX;;AACA,qBAAOxB,GAAG,IAAIqB,CAAd,EAAiB;AACf,sBAAMK,CAAC,GAAGT,KAAK,CAACjB,GAAD,CAAf;AACAwB,gBAAAA,IAAI,IAAIE,CAAR;;AAEA,oBAAIX,OAAJ,EAAa;AACXC,kBAAAA,KAAK,CAAChB,GAAD,CAAL,GAAa,KAAKH,eAAlB;AACD;;AAEDG,gBAAAA,GAAG;AACJ;;AAEDkB,cAAAA,KAAK,CAACd,IAAN,CAAWoB,IAAX;;AAEA,kBAAIL,MAAJ,EAAY;AACV;AACD;AACF;AACF;;AAED,iBAAO;AACLD,YAAAA,KADK;AAELL,YAAAA,IAAI,EAAEG,KAAK,CAACW,IAAN,CAAW,EAAX;AAFD,WAAP;AAID;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEC,QAAAA,MAAM,CAACf,IAAD,EAAeC,OAAf,EAAqE;AACzE,iBAAO,KAAKF,MAAL,CAAYC,IAAZ,EAAkBC,OAAlB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEK,QAAAA,MAAM,CAACN,IAAD,EAAe;AACnB,gBAAM;AAAEK,YAAAA;AAAF,cAAY,KAAKN,MAAL,CAAYC,IAAZ,EAAkB;AAAEM,YAAAA,MAAM,EAAE;AAAV,WAAlB,CAAlB;AACA,iBAAO,CAACD,KAAK,CAACnB,MAAd;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE8B,QAAAA,MAAM,CAACrB,GAAD,EAAc;AAClB,gBAAMsB,IAAI,GAAG,KAAKC,GAAL,CAASvB,GAAG,CAACe,WAAJ,EAAT,EAA4Bf,GAAG,CAACT,MAAhC,EAAwC,KAAKH,IAA7C,CAAb;AACA,eAAKM,KAAL;AACA,iBAAO4B,IAAP;AACD;;AAEOC,QAAAA,GAAG,CACTvB,GADS,EAETV,GAFS,EAGTW,IAHS,EAITuB,KAA0B,GAAG,QAJpB,EAKThC,GAAG,GAAG,CALG,EAMY;AACrB,cAAI,CAACS,IAAL,EAAW;AACT,mBAAO,QAAP;AACD;;AAED,cAAIT,GAAG,KAAKF,GAAZ,EAAiB;AACfW,YAAAA,IAAI,CAACe,IAAL,GAAY,KAAZ;AACAf,YAAAA,IAAI,CAACwB,KAAL,GAFe,CAGf;;AACA,gBAAIC,KAAK,GAAG,IAAZ;;AACA,iBAAK,MAAMC,CAAX,IAAgB1B,IAAI,CAACF,QAArB,EAA+B;AAC7B,kBAAI4B,CAAJ,EAAO;AACLD,gBAAAA,KAAK,GAAG,KAAR;AACA;AACD;AACF;;AAED,mBAAOA,KAAK,GAAGF,KAAH,GAAW,QAAvB;AACD,WAbD,MAaO;AACL,kBAAMI,GAAG,GAAG5B,GAAG,CAACR,GAAD,CAAf;AACA,kBAAMqC,IAAI,GAAG5B,IAAI,CAACF,QAAL,CAAc6B,GAAd,CAAb;AACA,kBAAMN,IAAI,GAAG,KAAKC,GAAL,CACXvB,GADW,EAEXV,GAFW,EAGXuC,IAHW,EAIX5B,IAAI,CAACe,IAAL,GAAY,QAAZ,GAAuBQ,KAJZ,EAKXhC,GAAG,GAAG,CALK,CAAb;AAQAS,YAAAA,IAAI,CAACwB,KAAL;;AACA,gBAAIH,IAAI,KAAK,QAAT,IAAqB,CAAAO,IAAI,QAAJ,YAAAA,IAAI,CAAEJ,KAAN,MAAgB,CAAzC,EAA4C;AAC1C,qBAAOxB,IAAI,CAACF,QAAL,CAAc6B,GAAd,CAAP,CAD0C,CAE1C;AACD;;AAED,mBAAON,IAAP;AACD;AACF;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE7B,QAAAA,GAAG,CAACO,GAAD,EAAcN,KAAK,GAAG,IAAtB,EAAqC;AACtC,gBAAMoC,MAAM,GAAG9B,GAAG,CAACe,WAAJ,EAAf;AACA,gBAAMzB,GAAG,GAAGwC,MAAM,CAACvC,MAAnB;AACA,eAAKwC,GAAL,CAASD,MAAT,EAAiBxC,GAAjB;;AAEA,cAAII,KAAJ,EAAW;AACT,iBAAKA,KAAL;AACA;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMK;;AAED,iBAAO,IAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAKUqC,QAAAA,GAAG,CAAC/B,GAAD,EAAcV,GAAd,EAA2B;AACpC,cAAIW,IAAI,GAAG,KAAKb,IAAhB;AACA,gBAAM4C,OAAO,GAAG1C,GAAG,GAAG,CAAtB;AACAW,UAAAA,IAAI,CAACwB,KAAL;;AACA,eAAK,IAAIjC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGF,GAAxB,EAA6BE,GAAG,EAAhC,EAAoC;AAClC,kBAAMoC,GAAG,GAAG5B,GAAG,CAACR,GAAD,CAAf;AACA,kBAAMyC,QAAQ,GAAGhC,IAAI,CAACF,QAAL,CAAc6B,GAAd,CAAjB;;AAEA,gBAAIK,QAAJ,EAAc;AACZA,cAAAA,QAAQ,CAACR,KAAT;AACAxB,cAAAA,IAAI,GAAGgC,QAAP;AACD,aAHD,MAGO;AACL,oBAAMC,OAAO,GAAG;AAAA;AAAA,gCAASN,GAAT,EAAcpC,GAAG,GAAG,CAApB,CAAhB;AACA0C,cAAAA,OAAO,CAACT,KAAR,GAAgB,CAAhB;AACAxB,cAAAA,IAAI,CAACF,QAAL,CAAc6B,GAAd,IAAqBM,OAArB;AACAjC,cAAAA,IAAI,GAAGiC,OAAP;AACD;;AAED,gBAAIF,OAAO,KAAKxC,GAAZ,IAAmBS,IAAI,CAACgB,KAA5B,EAAmC;AACjChB,cAAAA,IAAI,CAACe,IAAL,GAAY,IAAZ;AACD;AACF;AACF;;AAxSe,O;;yBA2SHjC,I","sourcesContent":["/*\n * @Author       : 程哲林\n * @Date         : 2023-02-20 20:03:15\n * @LastEditors  : 程哲林\n * @LastEditTime : 2023-05-08 18:09:03\n * @FilePath     : /mint-filter/src/index.ts\n * @Description  : 未添加文件描述\n * github https://github.com/ZhelinCheng/mint-filter\n */\n\nimport Node from './node';\n\ninterface FilterOptions {\n  // sensitive?: boolean;\n  replace?: boolean;\n  verify?: boolean;\n}\n\ninterface FilterData {\n  words: string[];\n  text: string;\n}\n\ninterface MintOptions {\n  customCharacter?: string;\n}\n\nexport class Mint {\n  root: Node = new Node('root');\n  customCharacter: string;\n\n  constructor(keys: string[], ops?: MintOptions) {\n    const len = keys.length;\n    this.customCharacter = ops?.customCharacter || '*';\n\n    for (let idx = 0; idx < len; idx++) {\n      this.add(keys[idx], false);\n    }\n    this.build();\n  }\n\n  // 构建\n  private build() {\n    const queue: Node[] = [];\n    queue.push(this.root);\n\n    let idx = 0;\n    while (queue.length > idx) {\n      const beginNode = queue[idx];\n      const map = beginNode.children;\n      for (const key in beginNode.children) {\n        const node = map[key];\n        let failNode = beginNode.fail;\n\n        while (failNode && !failNode.children[key]) {\n          failNode = failNode.fail;\n        }\n\n        node.fail = failNode?.children[key] || this.root;\n\n        queue.push(node);\n      }\n\n      idx++;\n    }\n  }\n\n  private search(\n    text: string,\n    options: FilterOptions = {\n      replace: true,\n    },\n  ) {\n    let node: Node | undefined = this.root;\n    const fText: string[] = [];\n    const oText: string[] = [];\n    const words: string[] = [];\n\n    const { replace = true, verify = false } = options;\n\n    const textLen = text.length;\n    for (let i = 0; i < textLen; i++) {\n      // const key = text.charAt(i);\n      const oKey = text[i];\n      const key = oKey.toLowerCase();\n\n      while (node && !node?.children[key]) {\n        node = node?.fail;\n      }\n      node = node?.children[key] || this.root;\n\n      fText.push(oKey);\n      oText.push(oKey);\n\n      if (node.word) {\n        let idx = i + 1 - node.depth;\n        let word = '';\n        while (idx <= i) {\n          const v = oText[idx];\n          word += v;\n\n          if (replace) {\n            fText[idx] = this.customCharacter;\n          }\n\n          idx++;\n        }\n\n        words.push(word);\n\n        if (verify) {\n          break;\n        }\n      }\n    }\n\n    return {\n      words,\n      text: fText.join(''),\n    };\n  }\n\n  /**\n   * 过滤文本\n   *\n   * @param text 文本内容\n   * @param options.replace 是否替换掉敏感词部位\n   * @returns FilterData\n   *\n   * @example\n   *\n   * ```typescript\n   * mint.add('无法通过')\n   * let status = mint.filter('这是一句无法通过的文本')\n   * console.log(status) // { words: [\"无法通过\"], text: \"这是一句****的文本\" }\n   *\n   * status = mint.filter('这是一句无法通过的文本', { replace: false })\n   * console.log(status) // { words: [\"无法通过\"], text: \"这是一句无法通过的文本\" }\n   * ```\n   */\n  filter(text: string, options?: Pick<FilterOptions, 'replace'>): FilterData {\n    return this.search(text, options);\n  }\n\n  /**\n   * 检测文本是否通过验证\n   *\n   * @param text 文本内容\n   * @returns Boolean\n   *\n   * @example\n   *\n   * ```typescript\n   * mint.add('无法通过')\n   * const status = mint.verify('这是一句无法通过的文本')\n   * console.log(status) // false\n   * ```\n   */\n  verify(text: string) {\n    const { words } = this.search(text, { verify: true });\n    return !words.length;\n  }\n\n  /**\n   * 删除关键字\n   *\n   * @param key 关键词\n   * @returns 状态（update ｜ delete），告知用户是删除了树上的节点还是单纯的更新了节点\n   *\n   * @example\n   *\n   * ```typescript\n   * const status = mint.delete('敏感词')\n   * ```\n   */\n  delete(key: string) {\n    const type = this.pop(key.toLowerCase(), key.length, this.root);\n    this.build();\n    return type;\n  }\n\n  private pop(\n    key: string,\n    len: number,\n    node?: Node,\n    carry: 'update' | 'delete' = 'delete',\n    idx = 0,\n  ): 'update' | 'delete' {\n    if (!node) {\n      return 'delete';\n    }\n\n    if (idx === len) {\n      node.word = false;\n      node.count--;\n      // 需要删除的情况\n      let isDel = true;\n      for (const k in node.children) {\n        if (k) {\n          isDel = false;\n          break;\n        }\n      }\n\n      return isDel ? carry : 'update';\n    } else {\n      const val = key[idx];\n      const next = node.children[val];\n      const type = this.pop(\n        key,\n        len,\n        next,\n        node.word ? 'update' : carry,\n        idx + 1,\n      );\n\n      node.count--;\n      if (type === 'delete' && next?.count === 0) {\n        delete node.children[val];\n        // node.children[val] = undefined\n      }\n\n      return type;\n    }\n  }\n\n  /**\n   * 新增敏感词\n   *\n   * @param key 关键词\n   * @param build 是否构建树，默认不用传递\n   * @returns 状态\n   *\n   * @example\n   *\n   * ```typescript\n   * const status = mint.add('敏感词')\n   * ```\n   */\n  add(key: string, build = true): boolean {\n    const lowKey = key.toLowerCase();\n    const len = lowKey.length;\n    this.put(lowKey, len);\n\n    if (build) {\n      this.build();\n      /* const queue: Node[] = [this.root];\n      let idx = 0;\n\n      while (queue.length > idx) {\n        const beginNode = queue[idx];\n        const map = beginNode.children;\n        const k = lowKey[idx];\n\n        // FIX: 可以优化\n        if (!k) {\n          break;\n        }\n\n        const node = map[k];\n        let failNode = beginNode.fail;\n\n        while (failNode && !failNode.children[lowKey]) {\n          failNode = failNode.fail;\n        }\n        node.fail = failNode?.children[lowKey] || this.root;\n\n        queue.push(node);\n        idx++;\n      } */\n    }\n\n    return true;\n  }\n\n  /* private put(key: string, len: number, node?: Node, idx = 0): Node {\n    if (!node) {\n      node = this.root;\n    }\n\n    // 基线条件\n    if (idx === len) {\n      node.word = true;\n      node.count++;\n      return node;\n    }\n\n    const val = key[idx];\n    const next = node.children[val];\n    const depth = idx + 1;\n    node.children[val] = this.put(\n      key,\n      len,\n      next || new Node(val, depth),\n      depth,\n    );\n\n    node.count++;\n    return node;\n  } */\n\n  private put(key: string, len: number) {\n    let node = this.root;\n    const lastIdx = len - 1;\n    node.count++;\n    for (let idx = 0; idx < len; idx++) {\n      const val = key[idx];\n      const nextNode = node.children[val];\n\n      if (nextNode) {\n        nextNode.count++;\n        node = nextNode;\n      } else {\n        const newNode = new Node(val, idx + 1);\n        newNode.count = 1;\n        node.children[val] = newNode;\n        node = newNode;\n      }\n\n      if (lastIdx === idx && node.depth) {\n        node.word = true;\n      }\n    }\n  }\n}\n\nexport default Mint;\n"]}