{"version":3,"sources":["file:///C:/chickenStarClient/client/assets/scripts/logic/fight/base/move/bullet/BulletMoveCentrifugation.ts"],"names":["BulletMoveCentrifugation","Vec3","BulletMoveLine","FixedUtil","MathAngle","tempPos","tempPos1","angleVelocity","roundCount","totalCount","oneWayTime","waitingTime","angle","startPos","nowPos","idx","init","set","multiplyScalar","abs","speed","voRatio","voAngle","getTruePosition","setLiftTime","t","info","isRound","configTab","Round","checkFlip","x","y","updateFrame","dt","Math","max","checkRotate","isDead","getPassTimeRoundCount","fly","Centrifugation","deltaTimeMovePostion","rotatePoint","add","setAbsPos","floor","passTime"],"mappings":"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","sourcesContent":["import { Mat4, Quat, Vec3, math, v2, v3 } from \"cc\";\nimport { AbsMoveType, BulletMove } from \"../AbsMove\";\nimport { BulletMoveLine } from \"./BulletMoveLine\";\nimport { FixedUtil } from \"../../../util/FixedUtil\";\nimport { MathAngle } from \"../../../../../framework/collision/Maths\";\nimport { BulletMoveRound } from \"./BulletMoveRound\";\n\nconst tempPos = new Vec3();\nconst tempPos1 = new Vec3();\nconst angleVelocity = new Vec3();\n\n/** 离心运动 包含离心回旋 */\nexport class BulletMoveCentrifugation extends BulletMoveLine {\n    roundCount: number //回旋次数\n    totalCount: number //总次数\n    oneWayTime: number //表里配置的为单程时间\n    waitingTime: number = 0  //等待时间 \n\n    angle: number = 0\n    angleVelocity: Vec3 = new Vec3()\n    startPos: Vec3 = new Vec3()\n    nowPos: Vec3 = new Vec3()\n\n    init(): void {\n        super.init()\n\n        this.angleVelocity.set(1, 0, 0)\n        this.angleVelocity.multiplyScalar(this.abs.speed * this.abs.voRatio)\n\n        this.angle = this.abs.voAngle\n        this.startPos.set(this.abs.getTruePosition())\n        this.nowPos.set(0, 0, 0)\n    }\n    setLiftTime(t: number) {\n\n        if (this.abs.info.isRound()) {\n            this.oneWayTime = t\n            this.roundCount = 0\n            this.totalCount = this.abs.info.configTab.Round[0] * 2\n            t = t * this.totalCount\n        }\n\n        super.setLiftTime(t)\n    }\n\n    checkFlip() {\n        if (this.waitingTime == 0) {\n            this.angleVelocity.x = -this.angleVelocity.x\n            this.angleVelocity.y = -this.angleVelocity.y\n        }\n    }\n\n    updateFrame(dt: number): void {\n        if (this.waitingTime > 0) {\n            this.waitingTime -= dt\n            this.waitingTime = Math.max(this.waitingTime, 0)\n            this.checkFlip()\n            this.checkRotate()\n            return\n        }\n\n        super.updateFrame(dt)\n        if (this.abs.isDead) {\n            return\n        }\n        if (this.abs && this.abs.info && this.abs.info.isRound()) {\n            if (this.roundCount != this.getPassTimeRoundCount()) {\n                this.roundCount = this.getPassTimeRoundCount()\n                if (this.roundCount == this.totalCount) {\n                    return\n                }\n                this.waitingTime = this.abs.info.configTab.Round[1]\n                this.checkFlip()\n            }\n        }\n    }\n\n    idx: number = 0\n    fly(dt: number): void {\n        this.angle = this.angle + this.abs.info.configTab.Centrifugation[1]\n\n        //计算新位置\n        FixedUtil.deltaTimeMovePostion(this.nowPos, this.nowPos, this.angleVelocity, dt)\n        MathAngle.rotatePoint(this.nowPos, this.angle, tempPos1)\n        tempPos1.add(this.startPos)\n        this.setAbsPos(tempPos1);\n\n    }\n\n    getPassTimeRoundCount() {\n        return Math.floor(this.passTime / this.oneWayTime)\n    }\n\n    // rotatePoint(point: Vec3, angle: number, out: Vec3): { x: number, y: number } {\n    //     const radians = angle * Math.PI / 180;\n    //     out.x = point.x * Math.cos(radians) - point.y * Math.sin(radians);\n    //     out.y = point.x * Math.sin(radians) + point.y * Math.cos(radians);\n    //     return out\n    // }\n}"]}